/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lewa.launcher;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import android.content.ContentResolver;
import android.database.Cursor;
import lewa.content.res.IconCustomizer;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.provider.Settings;
import android.provider.Settings.SettingNotFoundException;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.ActionMode;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.lewa.launcher.FolderInfo.FolderListener;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends RelativeLayout implements View.OnClickListener,
        FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener, DragController.ScrollView {
    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private FolderLayout mFolderLayout;
    private ImageView mFolderBg;
    private final LayoutInflater mInflater;
    private final IconCache mIconCache;
    private int mState = STATE_NONE;
    private boolean mRearrangeOnClose = false;
    public boolean mDeleteFolderOnDropCompleted = true;
    private FolderIcon mFolderIcon;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    boolean mItemsInvalidated = false;
    boolean mSuppressOnAdd = false;
    private int mFolderNameHeight;
    private int mFolderIndicatorHeight;
    private Rect mTempRect = new Rect();
    FolderEditText mFolderName;
    private LinearLayout mFolderNameLayout;
    private int mFolderHeight = -1;
    private int mFolderWidth = -1;

    DesktopIndicator indicator;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private boolean mDestroyed;
    private FolderStateListener mStateListener;

    private Drawable mFolderBoundDrawable;
    private Rect folderBoundRect = new Rect();
    /**
     * over this sdk version, no need to new dialog when rename folder, current
     * set to be a big value
     **/
    private static final int SDK_VERSION_RENAME_WITH_DIALOG = 137;
    private int mFolderCellHeight, mFolderHeightGap, mFolderCellWidth, mFolderWidthGap;

    private float[][] mIconPositionOffset;
    /**
     * Used to inflate the Workspace from XML.
     * 
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs){
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);
        mIconCache = ((LauncherApplication)context.getApplicationContext()).getIconCache();

        Resources res = getResources();
        mInputMethodManager = (InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE);
        mLauncher = (Launcher)context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);

        mFolderCellHeight = res.getDimensionPixelSize(R.dimen.folder_cell_height);
        mFolderHeightGap = res.getDimensionPixelSize(R.dimen.folder_height_gap);
        mFolderCellWidth = res.getDimensionPixelSize(R.dimen.folder_cell_width);
        mFolderWidthGap = res.getDimensionPixelSize(R.dimen.folder_width_gap);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mFolderLayout = (FolderLayout)findViewById(R.id.folder_content_container);
        mFolderBg = (ImageView)findViewById(R.id.folder_bg);
        Drawable d = mIconCache.getIcon("com_android_folder.png");
        if (d == null) {    // for supporting V4 theme
            d = mIconCache.getIcon("icon_folder_background.png");
        }
        mFolderBg.setImageDrawable(d);
        LinearLayout.LayoutParams folderBgParams = (LinearLayout.LayoutParams) mFolderBg.getLayoutParams();
        folderBgParams.height = (int) (IconCustomizer.sCustomizedIconHeight / FolderIcon.PREVIEW_SCALE);
        folderBgParams.width = (int) (IconCustomizer.sCustomizedIconWidth / FolderIcon.PREVIEW_SCALE);
        mFolderLayout.setFolder(this);

        mFolderName = (FolderEditText)findViewById(R.id.folder_name);
        mFolderNameLayout = (LinearLayout)findViewById(R.id.folder_name_layout);
        mFolderName.setFolder(this);
        mFolderName.setOnClickListener(this);//lqwang - pr955013 - modify
        mFolderName.setOnFocusChangeListener(this);

        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        mFolderNameHeight = mFolderName.getMeasuredHeight();
        Resources res = getResources();
        mFolderIndicatorHeight = res.getDimensionPixelSize(R.dimen.indicator_height);
        indicator = (DesktopIndicator)findViewById(R.id.folder_indicator);
        mFolderLayout.setIndicator(indicator);
        mFolderName.getBackground().setAlpha(0);

        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
//        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setFocusableInTouchMode(true);
        mFolderName.setFocusable(true);
        mFolderName.setImeOptions(EditorInfo.IME_ACTION_DONE);
        mFolderName.setInputType(mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
                            | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        mFolderBoundDrawable = res.getDrawable(R.drawable.folder_bound);
        mIconPositionOffset = new float[FolderScreen.CNT_PER_SCREEN][2];
    }

    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {

        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

    public void onClick(View v) {
      switch (v.getId()) {
          //lqwang - pr955013 - modify begin
          case R.id.folder_name:
            if (!isRenameFolderWithDialog()) {
                mFolderName.setHint("");
            }
            startEditingName();
            break;
          //lqwang - pr955013 - modify end
        default:
            if (mState != STATE_OPEN) {
                return;
            }
            if (mLauncher.isFloating()) {
                CellLayout.CellInfo cellInfo = getCellInfo(v);
                mStateListener.folderChildClick(cellInfo);
                return;
            }

            // Added by weihong, 20140910, When edit mode into the folder Click the
            // application icon, the icon is placed to restseat
            if (mLauncher.isEditMode()) {
                CellLayout.CellInfo cellInfo = getCellInfo(v);
                cellInfo.screen = mLauncher.getCurrentWorkspaceScreen();
                mLauncher.getFloating().startFloating(cellInfo);
                mStateListener.folderChildClick(cellInfo);
                mLauncher.getFloating().bringToFront();
                // Set the folder to the top
                this.bringToFront();
                return;
            }

            Object tag = v.getTag();
            if (tag instanceof ShortcutInfo) {
                // refactor this code from Folder
                ShortcutInfo item = (ShortcutInfo)tag;
                final Intent intent = item.intent;
                int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                LauncherModel.isRecommendShortcut(mLauncher, intent, (String) item.title);
                intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight()));
                Utilities.updateNewAddSymbol((View)v.getParent(), ((ShortcutInfo)tag).getPackageName());
                mLauncher.startActivitySafely(v, intent, item);
                // After starting App, close folder
                // mLauncher.closeFolder();
            }
            break;
        }
    }

    private CellLayout.CellInfo getCellInfo(View v) {
        ShortcutInfo shortcutInfo = (ShortcutInfo) v.getTag();
        View parent = (View) v.getParent();
        parent.setVisibility(View.INVISIBLE);

        if (parent instanceof ShortcutIcon) {
            CellLayout.CellInfo mCellInfo = new CellLayout.CellInfo();
            CellLayout.LayoutParams cellParams = new CellLayout.LayoutParams(shortcutInfo.cellX,
                    shortcutInfo.cellY, shortcutInfo.spanX, shortcutInfo.spanY);
            // #57642 Modify by Fan.Yang
            //parent.setLayoutParams(cellParams);
            ShortcutIcon icon = createAndAddShortcut(shortcutInfo);
            icon.setLayoutParams(cellParams);
            mCellInfo.cell = icon;
            mCellInfo.container = shortcutInfo.container;
            mCellInfo.cellX = shortcutInfo.cellX;
            mCellInfo.cellY = shortcutInfo.cellY;
            mCellInfo.spanX = shortcutInfo.spanX;
            mCellInfo.spanY = shortcutInfo.spanY;
            return mCellInfo;
        }

        return null;
    }

    public void removeShortcut(ShortcutIcon shortcut) {
        Object tag = shortcut.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo shortcutInfo = (ShortcutInfo) tag;
            mInfo.remove(shortcutInfo);
            shortcut.mFavorite.setOnClickListener(mLauncher);
            shortcut.mFavorite.setOnLongClickListener(mLauncher);
        }
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
        //folderName.setHint(getResources().getString(R.string.folder_hint_text));
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String name;
        if (TextUtils.isEmpty(mFolderName.getText())) {
            name = sFolderName;
            mFolderName.setText(name);
        } else {
            name = mFolderName.getText().toString();
        }
        mFolderName.getBackground().setAlpha(0);
        mInfo.setTitle(name);
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
//        requestFocus(); //lqwang - pr955013 - modify
        mFolderName.setCursorVisible(false);
        Selection.setSelection((Spannable)mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    public FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.cellY * FolderScreen.ITEMS_PER_ROW + lhs.cellX + lhs.screen * FolderScreen.CNT_PER_SCREEN;
            int rhIndex = rhs.cellY * FolderScreen.ITEMS_PER_ROW + rhs.cellX + rhs.screen * FolderScreen.CNT_PER_SCREEN;
            return (lhIndex - rhIndex);
        }
    }

    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        Collections.sort(items, new GridComparator());
    }

    void bind(FolderInfo info) {
        mInfo = info;
        placeInReadingOrder(info.contents);
        setupContentForNumItems(mInfo.getVisibleCnt());

        updateTextViewFocus();
        mInfo.addListener(this);
        mFolderName.setText(Utilities.convertStr(getContext(), mInfo.title.toString()));
        mStateListener = mLauncher.getFloating();
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     * 
     * @param context The application's context.
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder)LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    public void animateOpen(int folderTop, int folderArrowLeft) {
        mState = STATE_SMALL;
        updateContentUnreadNum();
        if (!(getParent() instanceof DragLayer)) {
            return;
        }
        centerAboutIcon(folderTop, folderArrowLeft);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        buildLayer();
        mItemsInvalidated = true;
    }

    public void openAnimationStart() {
        mState = STATE_ANIMATING;
        mStateListener.folderOpenStart(this);
        resetChildrenProperty();
    }

    public void openAnimationEnd() {
        mState = STATE_OPEN;
        setLayerType(LAYER_TYPE_NONE, null);
        initIconPositionOffset();
        mStateListener.folderOpenEnd(this);
    }

    public void setLayerType(int layerType, Paint paint) {
        // if sdk < 16, not allow
        if (Build.VERSION.SDK_INT < 16) {
            return;
        }
        super.setLayerType(layerType, paint);
    }

    public void animateClosed() {
        if (!(getParent() instanceof DragLayer)) {
            return;
        }
        //setLayerType(LAYER_TYPE_HARDWARE, null);
        //buildLayer();
        mItemsInvalidated = true;
    }

    public void closeAnimationStart() {
        // re compute the icons position offset after folder icon changed
        initIconPositionOffset();
        mState = STATE_ANIMATING;
        indicator.setAlpha(0f);
        mFolderName.setAlpha(0f);
        int currentScreen = mFolderLayout.getCurrentPage();
        FolderScreen screen = (FolderScreen) mFolderLayout.getChildAt(currentScreen);
        for (int j = 0; screen != null && j < screen.getChildCount(); j++) {
            screen.setChildrenNameVisible(j, true);
        }
        mStateListener.folderCloseStart();
    }

    public void closeAnimationEnd() {
        mFolderIcon.setTextVisible(true);
        mFolderIcon.invalidate();
        mFolderIcon.getFolderIconZone().setDrawingCacheEnabled(false);
        mFolderIcon.setVisibility(View.VISIBLE);
        onCloseComplete();
        setLayerType(LAYER_TYPE_NONE, null);
        mState = STATE_SMALL;
        mStateListener.folderCloseEnd();
        mInfo.opened = false;
        postDelayed(new Runnable() {
            @Override
            public void run() {
                if (mLauncher != null && mLauncher.getDragController() != null && !mLauncher.getDragController().isDragging()) {
                    mFolderIcon.scrollIconPreview(true);
                }
            }
        }, 200);
    }

    void notifyDataSetChanged() {
        // recreate all the children if the data set changes under us. We may want to do this more
        // intelligently (ie just removing the views that should no longer exist)
        mFolderLayout.removeAllViewsInLayout();
        bind(mInfo);
    }

    protected ShortcutIcon createAndAddShortcut(ShortcutInfo item) {
        final ShortcutIcon shortcut = (ShortcutIcon)mInflater.inflate(R.layout.application, this, false);
        shortcut.applyFromShortcutInfo(item, mIconCache);
        shortcut.mFavorite.setOnClickListener(this);
        shortcut.mFavorite.setOnLongClickListener(mFolderLayout);
        // Begin, added by zhumeiquan, for bug SW2 #39186, this method may be invoked before MessageModel.bindUnreadInfoIfNeeded()
        int unreadNum = 0;
        ComponentName cn = item.intent.getComponent();
        if (cn != null) {
            try {
                unreadNum = Settings.System.getInt(getContext().getContentResolver(), cn.getClassName());
            } catch (SettingNotFoundException e) {
                e.printStackTrace();
            }
        }
        // End
        shortcut.updateShortcutUnreadNum(unreadNum);
        mFolderIcon.updateFolderUnreadNum(item.intent.getComponent(), unreadNum);
        return shortcut;
    }

    public void notifyDrop() {
    
    }

    private void setupContentDimensions(final int count) {
        int pageCnt = (int)Math.ceil((double)count / FolderScreen.CNT_PER_SCREEN);
        mFolderLayout.removeAllViews();
        for (int i = 0; i < pageCnt; i++) {
            FolderScreen screen = new FolderScreen(mLauncher, i);
            mFolderLayout.addView(screen);
        }

        int added = 0;
        for (ShortcutInfo shortcut : mInfo.contents) {
            // shortcut state. if state != STATE_OK  or hidden app, don't show it.
            if (shortcut.state == ShortcutInfo.STATE_OK && !shortcut.isHidden()) {
                ShortcutIcon icon = createAndAddShortcut(shortcut);
                mFolderLayout.getScreen(added++).addView(icon);
                ShortcutInfo synced = (ShortcutInfo) LauncherModel.getSyncedItemInfo(shortcut);
                if (synced != null) {
                    shortcut = synced;
                    LauncherModel.moveItemInDatabase(mLauncher, shortcut, mInfo.id, shortcut.screen,
                            shortcut.cellX, shortcut.cellY);
                } else {
                    shortcut = icon.mInfo;
                    shortcut.container = mInfo.id;
                    icon.setTag(shortcut);
                    LauncherModel.addItemToDatabase(mLauncher, shortcut, mInfo.id, shortcut.screen,
                            shortcut.cellX, shortcut.cellY, false);
                }
            }
        }
        
        placeInReadingOrder(mInfo.contents);
        if (pageCnt > 0 && mFolderLayout.getCurrentPage() >= mFolderLayout.getChildCount()) {
            mFolderLayout.snapToPage(0);
            mFolderLayout.setCurrentPage(0);
        }
        indicator.setItems(mFolderLayout.getChildCount(), mFolderLayout.getCurrentPage());
        if (mFolderLayout.getChildCount() > 1) {
            indicator.setVisibility(View.VISIBLE);
        } else {
            indicator.setVisibility(View.GONE);
        }
    }

    public boolean isFull() {
        return false;
    }

    // Add by Fan.Yang for open folder animation
    // save the translationX and translationY
    float[][] mIconTranslation = new float[FolderIcon.NUM_ITEMS_IN_PREVIEW][2];
    float[] mBgTranslation = new float[2];
    int folderX,folderY;
    boolean isFolderShowInMaxRow = true;

    /*
     * compute the distance from icons to the pivotX&pivotY of folder
     *
    public void initIconPositionOffset2() {
        if (mIconPositionOffset == null) {
            mIconPositionOffset = new float[FolderScreen.CNT_PER_SCREEN][2];
        }

        FolderScreen layout = (FolderScreen) getFolderLayout().getChildAt(0);
        if (layout == null) {
            return;
        }
        final Display display = mLauncher.getWindowManager().getDefaultDisplay();
        final Point point = new Point();
        display.getSize(point);

        Rect rect = new Rect();
        int iconCustomWidth = IconCustomizer.sCustomizedIconWidth;
        for (int i = 0; i < layout.getChildCount(); i++) {
            ShortcutIcon shortcutIcon = (ShortcutIcon) layout.getChildAt(i);
            shortcutIcon.mFavorite.getGlobalVisibleRect(rect);
            int iconWidth = rect.right - rect.left;
            if (iconWidth > iconCustomWidth) {
                mIconPositionOffset[i][0] = rect.left - this.getPivotX() - folderX
                        + (iconWidth - iconCustomWidth) / 2;
            } else {
                mIconPositionOffset[i][0] = rect.left - this.getPivotX() - folderX;
            }
            mIconPositionOffset[i][1] = rect.top - this.getPivotY() - folderY;
        }
    }

    // compute the icon X&Y translation when close the folder
    public float[] getIconTranslation2(int index, Rect folderIconBgRect, float mFolderScale) {
        Rect rect = mFolderIcon.getIconPreviewRect(index);
        if (rect != null) {
            float folderIconBgCenterX = this.getPivotX() / getFolderWidth()
                    * (folderIconBgRect.right - folderIconBgRect.left) + folderIconBgRect.left;
            float folderIconBgCenterY = this.getPivotY() / getFolderHeight()
                    * (folderIconBgRect.bottom - folderIconBgRect.top) + folderIconBgRect.top;
            float iconPreviewCenterXOffset = rect.left - folderIconBgCenterX;
            float iconPreviewCenterYOffset = rect.top - folderIconBgCenterY;
            mIconTranslation[index][0] = mIconPositionOffset[index][0] - iconPreviewCenterXOffset / mFolderScale;
            mIconTranslation[index][1] = mIconPositionOffset[index][1] - iconPreviewCenterYOffset / mFolderScale;
            return mIconTranslation[index];
        }
        return null;
    }
    */
    
    // compute the distance from icons to the left&top of folder view
    public void initIconPositionOffset() {
        if (mIconPositionOffset == null) {
            mIconPositionOffset = new float[FolderScreen.CNT_PER_SCREEN][2];
        }

        int current = mFolderLayout.getCurrentPage();
        FolderScreen layout = (FolderScreen) mFolderLayout.getChildAt(current);
        if (layout == null) {
            return;
        }

        Rect rect = new Rect();
        int iconCustomWidth = IconCustomizer.sCustomizedIconWidth;
        for (int i = 0; i < layout.getChildCount(); i++) {
            ShortcutIcon shortcutIcon = (ShortcutIcon) layout.getChildAt(i);
            boolean result = shortcutIcon.mFavorite.getGlobalVisibleRect(rect);
            int iconWidth = rect.right - rect.left;
            if (iconWidth > iconCustomWidth) {
                mIconPositionOffset[i][0] = rect.left - folderX + (iconWidth - iconCustomWidth) / 2;
            } else {
                mIconPositionOffset[i][0] = rect.left - folderX;
            }
            mIconPositionOffset[i][1] = rect.top - folderY;
        }
    }

    // compute the icon X&Y translation when close the folder
    public float[] getIconTranslation(int index, Rect folderIconBgRect, float mFolderScale) {
        Rect rect = mFolderIcon.getIconPreviewRect(index);
        float iconPreviewLeftOffset, iconPreviewTopOffset;
        if (rect != null || mIconPositionOffset[index] != null) {
            iconPreviewLeftOffset = rect.left - folderIconBgRect.left;
            iconPreviewTopOffset = rect.top - folderIconBgRect.top;
            float xOffset = mIconPositionOffset[index][0] - iconPreviewLeftOffset / mFolderScale;
            float yOffset = mIconPositionOffset[index][1] - iconPreviewTopOffset / mFolderScale;
            mIconTranslation[index][0] = xOffset;
            mIconTranslation[index][1] = yOffset;
            return mIconTranslation[index];
        }
        return null;
    }

    public void setChildrenTranslationAndScale(float factor, int currentScreen,
            Rect folderIconBgRect, float scale){
        FolderScreen screen = (FolderScreen) mFolderLayout.getChildAt(currentScreen);
        float[] translation;
        float layoutTranslation = 0;
        for (int j = 0; screen != null && j < screen.getChildCount(); j++) {
            translation = getIconTranslation(j, folderIconBgRect,
                    scale);
            if (translation != null) {
                float transX = translation[0] * (1 - factor);
                float transY = translation[1] * (1 - factor);
                if (j == 0) {
                    layoutTranslation = -transY;
                    mFolderLayout.setTranslationY(layoutTranslation);
                }
                screen.setChildrenTranslationAndScale(j, -transX, -transY - layoutTranslation, factor);
            }
        }
    }

    public void resetChildrenProperty() {
        for (int i = 0; mFolderLayout != null && i < mFolderLayout.getChildCount(); i++) {
            FolderScreen screen = (FolderScreen) mFolderLayout.getChildAt(i);
            for (int j = 0; screen != null && j < screen.getChildCount(); j++) {
                screen.setChildrenTranslationAndScale(j, 0f, 0f, 1f);
                screen.setChildrenNameVisible(j, false);
            }
        }
        mFolderName.setAlpha(1f);
        mFolderLayout.setTranslationY(0);
        mFolderBg.setAlpha(0f);
        mFolderIcon.setVisibility(View.INVISIBLE);
        indicator.setAlpha(1f);
        indicator.setItems(mFolderLayout.getChildCount(), mFolderLayout.getCurrentPage());
        if (mFolderLayout.getChildCount() > 1) {
            indicator.setVisibility(View.VISIBLE);
        } else {
            indicator.setVisibility(View.GONE);
        }
    }

    public void setFolderBgAlpha(float factor) {
        mFolderBg.setAlpha(factor);
    }

    String sFolderName;
    public void startEditingName() {
        mIsEditingName = true;
        mFolderName.getBackground().setAlpha(255);
        mFolderName.setCursorVisible(true);
        sFolderName = mFolderName.getText().toString();
    }

    public boolean isEventOverFolder(MotionEvent ev) {
        FolderInfo info = getFolderIcon().getFolderInfo();
        int currentPage = getFolderLayout().getCurrentPage();
        FolderScreen folderScreen = (FolderScreen) getFolderLayout().getChildAt(currentPage);
        if (info == null || folderScreen == null) {
            return false;
        }

        int y = (int) (ev.getY() /*- mFolderNameHeight*/);
        int shortcutCount = folderScreen.getChildCount();
        int row = shortcutCount / FolderScreen.ITEMS_PER_ROW ;
        int column = shortcutCount % FolderScreen.ITEMS_PER_ROW;
        int zeroY = folderY +mFolderNameHeight;
        if (y > zeroY && y < zeroY + row * mFolderCellHeight ) {
            return true;
        }
        if (y > zeroY + row * mFolderCellHeight && y < zeroY + (row + 1) * mFolderCellHeight
                && ev.getX() > folderX && ev.getX() < column * mFolderCellWidth + folderX) {
            return true;
        }
        return false;
    }

    public int getCurrentHeight() {
        int rowCount = 0;
        int maxCount = getResources().getInteger(R.integer.folder_max_count_y);
        FolderScreen current = (FolderScreen) mFolderLayout.getChildAt(mFolderLayout.getCurrentPage());
        if (current != null) {
            rowCount = (int) Math.ceil(current.getChildCount()
                    / (float) FolderScreen.ITEMS_PER_ROW);
            if (indicator.getChildCount() > 0) {
                return getFolderHeight() - (maxCount - rowCount) * mFolderCellHeight;
            } else {
                return getFolderHeight() - (maxCount - rowCount) * mFolderCellHeight
                        - mFolderIndicatorHeight;
            }
        }
        return mFolderHeight;
    }

    public int[] getFolderLastPosition(){
        int screen = Math.max(mFolderLayout.getChildCount() - 1, 0);
        int count = mInfo.contents.size();

        int preCount = FolderScreen.CNT_PER_SCREEN * screen;
        int curCount = count - preCount;
        int[] result = new int[2];
        result[0] = curCount % FolderScreen.ITEMS_PER_ROW;
        result[1] = curCount / FolderScreen.ITEMS_PER_ROW;
        return result;
    }

    public int[] computeFolderChildOffset(int x, int y, boolean isNextPage) {
        int[] offset = new int[4];
        computeChildOffset(offset, y, x, isNextPage);
        return offset;
    }

    public int[] computeOnClickedChildOffset(int x,int y) {
        int[] offset = new int[4];

        computeChildOffset(offset, y, x, false);
        return offset;
    }

    private void computeChildOffset(int[] offset, int row, int column, boolean isNextPage){
        int page = mLauncher.getWorkspace().getCurrentPage();
        int screen = mFolderLayout.getChildCount() - 1;

        int[] bubble = mLauncher.getBubbleSize();
        int hSpacing = (mFolderCellWidth - bubble[0]) / 2;
        int vSpacing = (mFolderCellHeight - bubble[1]) / 2;

        offset[0] = (((CellLayout)mLauncher.getWorkspace().getChildAt(page)).getCellWidth() - bubble[0]) / 2;
        offset[1] = (((CellLayout)mLauncher.getWorkspace().getChildAt(page)).getCellHeight() - bubble[1]) / 2;

        offset[2] = folderX + column * mFolderCellWidth + hSpacing
                + mFolderLayout.getPaddingLeft();
        offset[3] = folderY + row * mFolderCellHeight + vSpacing
                + mFolderLayout.getPaddingTop() + mFolderNameHeight;
        if (isNextPage) {
            offset[2] += mFolderWidth;
        }
    }

    public void snapToLastPage(){
        addEmptyPageIfNeed();
        mFolderLayout.snapToLastPage();
    }

    public boolean addEmptyPageIfNeed() {
        int lastPage = mFolderLayout.getChildCount() - 1;
        FolderScreen folderScreen = (FolderScreen) mFolderLayout
                .getChildAt(lastPage);

        if (folderScreen != null && folderScreen.getChildCount() == FolderScreen.CNT_PER_SCREEN) {
            FolderScreen screen = new FolderScreen(mLauncher, ++lastPage);
            mFolderLayout.addView(screen);
            return true;
        }
        return false;
    }

    public boolean removeEmptyPageIfNeed(){
        int lastPage = mFolderLayout.getChildCount() - 1;
        FolderScreen folderScreen = (FolderScreen) mFolderLayout
                .getChildAt(lastPage);
        if (folderScreen == null) {
            return true;
        }

        if (folderScreen.getChildCount() == 0) {
            mFolderLayout.removeView(folderScreen);
            return true;
        }
        return false;
    }

    public void pageEndMoving() {
        mStateListener.folderPageSwitch();
    }

    @Override
    protected void dispatchDraw(Canvas canvas) {
        // TODO Auto-generated method stub
        super.dispatchDraw(canvas);
        if (mLauncher.getDragController().isDragging() && mState == STATE_OPEN) {
            int left = mFolderLayout.getPaddingLeft()+ getPaddingLeft();
            int right = getFolderWidth() - mFolderLayout.getPaddingRight() - getPaddingRight();
            folderBoundRect.set(left, mFolderNameHeight, right, getCurrentHeight());
            mFolderBoundDrawable.setBounds(folderBoundRect);
            mFolderBoundDrawable.draw(canvas);
            mLauncher.getDeleteZone().bringToFront();
        }
    }

    private void centerAboutIcon(int folderTop, int folderLeft) {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams)getLayoutParams();

        final Display display = mLauncher.getWindowManager().getDefaultDisplay();
        final Point point = new Point();
        display.getSize(point);

        mFolderWidth = getFolderWidth();
        mFolderHeight = getFolderHeight();
        folderX = (point.x - mFolderWidth) / 2;
        folderY = folderTop;

        lp.width = mFolderWidth;
        lp.height = mFolderHeight;
        lp.x = folderX;
        lp.y = folderY;

        LinearLayout.LayoutParams folderBgParams = (LinearLayout.LayoutParams) mFolderBg.getLayoutParams();
        mBgTranslation[0] = this.getPivotX() - folderBgParams.height * this.getPivotX() / mFolderHeight;
        mBgTranslation[1] = this.getPivotY() - folderBgParams.width * this.getPivotY() / mFolderWidth;
    }

    /**
     * get folder height, please make sure folder height equal with folder width
     * 
     * @return
     */
    public int getFolderHeight() {
        if (mFolderHeight != -1) {
            return mFolderHeight;
        }
        int rowCount = getRowCount();
        if (isFolderShowInMaxRow) {
            rowCount = getResources().getInteger(R.integer.folder_max_count_y);
        }
        int pageHeight = mFolderLayout.getPaddingTop() + mFolderLayout.getPaddingBottom()
                         + (rowCount * mFolderCellHeight) + (Math.max((rowCount - 1), 0) * mFolderHeightGap);
        LayoutParams iconZoneParams = (RelativeLayout.LayoutParams)mFolderLayout.getLayoutParams();
        iconZoneParams.height = pageHeight;
        return getPaddingTop() + getPaddingBottom() + pageHeight + mFolderIndicatorHeight + mFolderNameHeight;
    }

    public int getFolderWidth() {
        if (mFolderWidth != -1) {
            return mFolderWidth;
        }
        int columnCount = getResources().getInteger(R.integer.folder_max_count_y);
        int pageWidth = mFolderLayout.getPaddingLeft() + mFolderLayout.getPaddingRight()
                + (columnCount * mFolderCellWidth) + (Math.max((columnCount - 1), 0) * mFolderWidthGap);
        return getPaddingLeft() + getPaddingRight() + pageWidth;
    }

    public int getFolderNameHeight() {
        return mFolderNameHeight;
    }

    public int getRowCount() {
        int rowCount = 0;
        FolderScreen firstScreen = (FolderScreen)mFolderLayout.getChildAt(0);
        if (firstScreen != null) {
            rowCount = (int)Math.ceil(firstScreen.getChildCount() / (float)FolderScreen.ITEMS_PER_ROW);
        }
        return rowCount;
    }

    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams)getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
    }

    private void onCloseComplete() {
        DragLayer parent = (DragLayer)getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget((DropTarget)mFolderLayout);
        clearFocus();
        mFolderIcon.requestFocus();

        if (mRearrangeOnClose) {
            setupContentForNumItems(mInfo.getVisibleCnt());
            mRearrangeOnClose = false;
        }
        //mFolderIcon.loadItemIcons();
        // if (getItemCount() <= 1) {
        // replaceFolderWithFinalItem();
        // }
    }

    private void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);
                View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                int visibleCnt = mInfo.getVisibleCnt();
                if (visibleCnt == 1) {
                    ShortcutInfo finalItem = mInfo.contents.get(0);
                    child = mLauncher.createShortcut(R.layout.application, cellLayout, finalItem);
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container, mInfo.screen,
                            mInfo.cellX, mInfo.cellY);
                }
                if (visibleCnt <= 1) {
                    // Remove the folder
                    // Begin, need delete the invisible item in the folder, 20131105, zhumeiquan
                    for (ShortcutInfo info : mInfo.contents) {
                        if (info.state != ShortcutInfo.STATE_OK) {
                            LauncherModel.deleteItemFromDatabase(mLauncher, info);
                        }
                    }
                    // End
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    cellLayout.removeView(mFolderIcon);
                    if (mFolderIcon!=null && mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget)mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.
                if (child != null) {
                    mLauncher.getWorkspace().addInScreen(child, mInfo.container, mInfo.screen, mInfo.cellX,
                            mInfo.cellY, mInfo.spanX, mInfo.spanY);
                }
            }
        };
        View finalChild = mFolderLayout.getItemAt(0);
        if (finalChild != null) {
            mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        } else {
            // if there is only one item left in folder, after pulling it to workspace, should delete folder
            removeEmptyFolder();
        }
        mDestroyed = true;
    }
    
    void removeEmptyFolder() {
        new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);
                int visibleCnt = mInfo.getVisibleCnt();
                if (visibleCnt < 1) {
                    for (ShortcutInfo info : mInfo.contents) {
                        if (info.state != ShortcutInfo.STATE_OK) {
                            LauncherModel.deleteItemFromDatabase(mLauncher, info);
                        }
                    }
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    //yixiao add #70162 2015.2.12
                    if(cellLayout!=null && mFolderIcon!=null){
                        cellLayout.removeView(mFolderIcon);
                    }
                    if (mFolderIcon!=null && mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget)mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
            }
        }.run();
    }

    FolderLayout getFolderLayout() {
        return mFolderLayout;
    }

    public static void dismissFolder(final Launcher launcher, final FolderInfo info) {
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                int screen = 0;
                int[] vacant = new int[2];
                View child = null;
                // Move the item from the folder to the workspace, in the
                // position of the folder
                if (info.contents != null) {
                    for (ShortcutInfo shortcutInfo : info.contents) {
                        screen = launcher.getWorkspace().getChildCount() - 1;
                        CellLayout lastCellLayout = launcher.getCellLayout(info.container, screen);
                        child = launcher.createShortcut(R.layout.application, lastCellLayout, shortcutInfo);

                        // find cell from last
                        boolean find = lastCellLayout.getLastVacantCell(vacant, 1, 1);
                        if (!find) {
                            screen++;
                            vacant[0] = 0;
                            vacant[1] = 0;
                            launcher.getWorkspace().addScreen(screen);
                        }
                        LauncherModel.addOrMoveItemInDatabase(launcher, shortcutInfo, info.container, screen,
                                vacant[0], vacant[1]);
                        // We add the child after removing the folder to prevent both from existing at the same time in the CellLayout.
                        if (child != null) {
                            launcher.getWorkspace().addInScreen(child, info.container, screen, vacant[0], vacant[1],
                                    shortcutInfo.spanX, shortcutInfo.spanY);
                        }
                    }
                }

            }
        };
        launcher.runOnUiThread(onCompleteRunnable);
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        int visibleCnt = mInfo.getVisibleCnt();
        if (visibleCnt > 0) {
            View lastChild = mFolderLayout.getItemAt(visibleCnt - 1);
            if (lastChild != null) {
                mFolderName.setNextFocusDownId(lastChild.getId());
                mFolderName.setNextFocusRightId(lastChild.getId());
                mFolderName.setNextFocusLeftId(lastChild.getId());
                mFolderName.setNextFocusUpId(lastChild.getId());
            }
        }
    }

    public void onAdd(ShortcutInfo item) {
        setupContentForNumItems(mInfo.getVisibleCnt());
    }

    @Override
    public void onAdd(ArrayList<ShortcutInfo> items) {
        setupContentForNumItems(mInfo.getVisibleCnt());
    }

    public void onRemove(ShortcutInfo item) {
        int visibleCnt = mInfo.getVisibleCnt();
        setupContentForNumItems(visibleCnt);
        if (visibleCnt <= 0 && mDeleteFolderOnDropCompleted && !mLauncher.isFloating()) {
            mFolderBg.setVisibility(View.GONE);
            mLauncher.closeFolder();
            replaceFolderWithFinalItem();
        }
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void onTitleChanged(CharSequence title) {
        
    }

    void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (View v : list) {
            ItemInfo info = (ItemInfo)v.getTag();
            LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, info.screen, info.cellX, info.cellY);
        }
        placeInReadingOrder(mInfo.contents);
    }

    public ArrayList<View> getItemsInReadingOrder() {
        mItemsInReadingOrder.clear();
        int totalScreenCnt = mFolderLayout.getChildCount();
        for (int i = 0; i < totalScreenCnt; i++) {
            FolderScreen screen = (FolderScreen)mFolderLayout.getChildAt(i);
            int itemCntPerScreen = screen.getChildCount();
            for (int j = 0; j < itemCntPerScreen; j++) {
                View v = screen.getChildAt(j);
                if (v != null) {
                    mItemsInReadingOrder.add(v);
                }
            }
        }
        return mItemsInReadingOrder;
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            if (!isRenameFolderWithDialog()) {
                mFolderName.setHint("");
            }
            startEditingName();
        }
    }

    /**
     * Update unread number of the content shortcut.
     */
    private void updateContentUnreadNum() {
        int totalScreenCnt = mFolderLayout.getChildCount();
        for (int i = 0; i < totalScreenCnt; i++) {
            FolderScreen screen = (FolderScreen)mFolderLayout.getChildAt(i);
            int itemCntPerScreen = screen.getChildCount();
            for (int j = 0; j < itemCntPerScreen; j++) {
                ShortcutIcon shortcut = (ShortcutIcon)screen.getChildAt(j);
                if (shortcut != null) {
                    shortcut.updateShortcutUnreadNum();
                }
            }
        }
    }

    public int getState() {
        return mState;
    }

    public static boolean isRenameFolderWithDialog() {
        return false;
        // return VERSION.SDK_INT < SDK_VERSION_RENAME_WITH_DIALOG;
    }

    @Override
    public void onReBind() {
        setupContentDimensions(mInfo.getVisibleCnt());
        //bind(mInfo);
    }

    @Override
    public void onUpdate() {
        // TODO Auto-generated method stub
        computeIconPositionByHerSister();
    }

    private void computeIconPositionByHerSister(){
        FolderScreen layout = (FolderScreen) getFolderLayout().getChildAt(0);
        if (layout == null) {
            return;
        }
        int last = layout.getChildCount() - 1;
        int brotherX = last % FolderScreen.ITEMS_PER_ROW;
        if (brotherX != last) {
            mIconPositionOffset[last][0] = mIconPositionOffset[brotherX][0];
            mIconPositionOffset[last][1] = mIconPositionOffset[brotherX][1] + mFolderCellHeight;
        } else {
            mIconPositionOffset[last][0] = mIconPositionOffset[Math.max(last - 1, 0)][0] + mFolderCellWidth;
            mIconPositionOffset[last][1] = mIconPositionOffset[brotherX][1];
        }
    }

    interface FolderStateListener {
        public void folderOpenStart(Folder folder);
        public void folderOpenEnd(Folder folder);
        public void folderCloseStart();
        public void folderCloseEnd();
        public void folderPageSwitch();
        public void folderChildClick(CellLayout.CellInfo cellInfo);
    }

    // Add by Fan.Yang for bug#51931
    public boolean handleTouchDown(MotionEvent ev){
        float x = ev.getX();float y = ev.getY();
        if ((x < folderX && y > folderY && y < folderY + mFolderHeight)
                || (x > mFolderWidth && y > folderY && y < folderY + mFolderHeight)) {
            return true;
        }
        return mState == Folder.STATE_ANIMATING;
    }

    public boolean isOpen(){
        return mState == STATE_OPEN ;
    }

    //#51745 Add by Fan.Yang
    public int getCurrentDragIndex() {
        ArrayList<View> list = getItemsInReadingOrder();
        ShortcutInfo shortcutInfo = mFolderLayout.getCurrentDragInfo();
        int savedIndex = mFolderLayout.getCurrentDragIndex();
        int index = -1;
        if (shortcutInfo != null && savedIndex != -1) {
            int i = 0;
            for (View v : list) {
                ShortcutInfo info = (ShortcutInfo) v.getTag();
                if (info.equals(shortcutInfo)) {
                    index = i;
                    break;
                }
                i++;
            }
        }
        return index;
    }

    public boolean isPageMoving() {
        return mFolderLayout.isPageMoving();
    }

    public void setCurrentPage(int page) {
        int child = mFolderLayout.getChildCount() - 1;
        if (page < 0 || page > child) {
            return;
        }
        mFolderLayout.setCurrentPage(page);
    }

    @Override
    public int getLeftSide() {
        return folderX;
    }

    @Override
    public int getRightSide() {
        return folderX + getFolderWidth();
    }
}
